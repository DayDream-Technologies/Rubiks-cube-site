<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Rubik's Cube</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        #home-button {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ff4500;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
            transition: background-color 0.3s;
        }
        #home-button:hover {
            background-color: #ff6347;
        }
        #info {
            position: absolute;
            top: 75px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #cubeState {
            position: absolute;
            top: 75px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            width: 200px;
            height: 300px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .face-display {
            white-space: pre;
            text-align: center;
        }
        #controls {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1001;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #ff4500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #ff6347;
        }
        
        /* Statistics Popup Styles */
        .stats-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #222;
            color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            z-index: 2000;
            text-align: center;
            min-width: 300px;
            border: 2px solid #ff4500;
        }
        
        .stats-popup h2 {
            color: #ff4500;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .stats-popup .stat-item {
            margin: 15px 0;
            font-size: 18px;
        }
        
        .stats-popup .stat-value {
            color: #ff4500;
            font-weight: bold;
            font-size: 20px;
        }
        
        .stats-popup button {
            margin-top: 20px;
            background-color: #ff4500;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .stats-popup button:hover {
            background-color: #ff6347;
        }
        
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1999;
        }
        
        /* Difficulty Dropdown Styles */
        .difficulty-dropdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #222;
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            z-index: 2000;
            text-align: center;
            min-width: 250px;
            border: 2px solid #ff4500;
        }
        
        .difficulty-dropdown h3 {
            color: #ff4500;
            margin-bottom: 20px;
            font-size: 20px;
        }
        
        .difficulty-option {
            display: block;
            width: 100%;
            padding: 12px 15px;
            margin: 8px 0;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            text-align: left;
        }
        
        .difficulty-option:hover {
            background-color: #ff4500;
        }
        
        .difficulty-option .move-count {
            color: #ff4500;
            font-weight: bold;
            float: right;
        }
    </style>
</head>
<body>
    <header style="position: fixed; top: 0; left: 0; right: 0; background-color: #222; color: white; padding: 30px; text-align: center; z-index: 1000;">
        <button id="home-button" onclick="window.location.href='index.html'">Home</button>
    </header>
    <div id="info">
        Controls:<br>
        Mouse: Rotate view<br>
        Scroll: Zoom<br>
        Keys: Rotate faces (W, Y, R, O, B, G)<br>
        Reverse Rotation: Hold shift + key
    </div>
    <div id="cubeState">
        <div class="face-display" id="top-face"></div>
        <div class="face-display" id="right-face"></div>
        <div class="face-display" id="front-face"></div>
        <div class="face-display" id="back-face"></div>
        <div class="face-display" id="bottom-face"></div>
        <div class="face-display" id="left-face"></div>
    </div>
    <div id="controls">
        <button onclick="resetCube()">Reset</button>
        <button onclick="scrambleCube()">Scramble</button>
        <button onclick="generateDailyPuzzle()">Daily Puzzle</button>
        <button onclick="showDifficultyDropdown()">New Puzzle</button>
    </div>

    <footer style="position: fixed; bottom: 0; left: 0; right: 0; background-color: #222; color: white; padding: 12px; text-align: center; z-index: 1000;">
        <p>&copy; 2025 DayDream Technologies. All rights reserved.</p>
        <p>Contact us at <a href="mailto:info@daydreamtechnologies.net" style="color: #ff4500; text-decoration: none;">info@daydreamtechnologies.net</a></p>
    </footer>

    <!-- Statistics Popup -->
    <div id="stats-overlay" class="popup-overlay" style="display: none;"></div>
    <div id="stats-popup" class="stats-popup" style="display: none;">
        <h2>ðŸŽ‰ Daily Puzzle Solved!</h2>
        <div class="stat-item">
            <span>Moves Used:</span>
            <div class="stat-value" id="moves-used">0</div>
        </div>
        <div class="stat-item">
            <span>Time Taken:</span>
            <div class="stat-value" id="time-taken">0:00</div>
        </div>
        <div class="stat-item">
            <span>Attempts:</span>
            <div class="stat-value" id="attempts">1</div>
        </div>
        <button onclick="closeStatsPopup()">Continue</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let cubelets = [];
        let isAnimating = false;
        let rotateLeft = 1;
        let currentRotation = 0;
        let targetRotation = 0;
        let rotatingFace = null;
        let rotatingCubes = [];
        let rotatingAxis = new THREE.Vector3();
        let rotatingPivot = new THREE.Vector3();
        const CUBELET_SIZE = 0.95;
        const ROTATION_SPEED = 0.1;
        const colors = {
            white: 0xffffff,
            yellow: 0xffff00,
            red: 0xff0000,
            orange: 0xffa500,
            blue: 0x0000ff,
            green: 0x00ff00
        };
        let scrambleQueue = [];
        let isScrambling = false;
        let moveHistory = []; // Store all moves in order
        let dailyPuzzleApplied = false; // Track if daily puzzle has been applied

        // Statistics tracking variables
        let dailyPuzzleStartTime = null;
        let dailyPuzzleAttempts = 0;
        let dailyPuzzleSolved = false;
        let solvedState = null; // Store the solved state for comparison
        let dailyPuzzleReady = false; // Track when daily puzzle is ready for solving
        
        // Manual scramble statistics tracking variables
        let manualScrambleStartTime = null;
        let manualScrambleAttempts = 0;
        let manualScrambleSolved = false;
        let manualScrambleActive = false; // Track if manual scramble is active
        
        // New puzzle statistics tracking variables
        let newPuzzleStartTime = null;
        let newPuzzleAttempts = 0;
        let newPuzzleSolved = false;
        let newPuzzleActive = false; // Track if new puzzle is active
        let newPuzzleDifficulty = ''; // Store the current difficulty

        // Daily Puzzle Generator
        function generateDailyPuzzle() {
            if (isScrambling) return;
            
            // Always reset the cube to solved state before applying daily puzzle
            resetCube();
            dailyPuzzleApplied = false;
            
            // Initialize statistics tracking for new daily puzzle
            dailyPuzzleStartTime = Date.now();
            dailyPuzzleAttempts++;
            dailyPuzzleSolved = false;
            dailyPuzzleReady = false;
            
            // Reset new puzzle statistics
            newPuzzleStartTime = null;
            newPuzzleAttempts = 0;
            newPuzzleSolved = false;
            newPuzzleActive = false;
            newPuzzleDifficulty = '';
            
            // Store the solved state for comparison
            solvedState = new CubeState();
            
            const moves = getDailyPuzzleMoves();
            // console.log('Daily Puzzle Moves:', moves);
            
            // Clear move history and scramble queue
            moveHistory = [];
            scrambleQueue = [];
            
            // Convert moves to rotation commands
            const moveToRotation = {
                'U': { face: 'white', angle: Math.PI / 2, direction: 1 },
                "U'": { face: 'white', angle: Math.PI / 2, direction: -1 },
                'D': { face: 'yellow', angle: Math.PI / 2, direction: 1 },
                "D'": { face: 'yellow', angle: Math.PI / 2, direction: -1 },
                'L': { face: 'orange', angle: Math.PI / 2, direction: 1 },
                "L'": { face: 'orange', angle: Math.PI / 2, direction: -1 },
                'R': { face: 'red', angle: Math.PI / 2, direction: 1 },
                "R'": { face: 'red', angle: Math.PI / 2, direction: -1 },
                'F': { face: 'blue', angle: Math.PI / 2, direction: 1 },
                "F'": { face: 'blue', angle: Math.PI / 2, direction: -1 },
                'B': { face: 'green', angle: Math.PI / 2, direction: 1 },
                "B'": { face: 'green', angle: Math.PI / 2, direction: -1 }
            };
            
            // Add moves to scramble queue
            moves.forEach(move => {
                const rotation = moveToRotation[move];
                if (rotation) {
                    scrambleQueue.push(rotation);
                }
            });
            
            // Hide the cube before starting daily puzzle
            hideCube();
            
            // Start the first move
            if (scrambleQueue.length > 0) {
                isScrambling = true;
                dailyPuzzleApplied = true;
                const move = scrambleQueue.shift();
                rotateLeft = move.direction || 1; // Use move direction or default to 1
                startRotation(move.face, move.angle);
            }
        }

        // Function to hide the cube
        function hideCube() {
            cubelets.forEach(cubelet => {
                cubelet.visible = false;
            });
        }

        // Function to show the cube
        function showCube() {
            cubelets.forEach(cubelet => {
                cubelet.visible = true;
            });
        }

        // Function to check if cube is solved
        function checkIfSolved() {
            // Check for daily puzzle solve
            if (dailyPuzzleApplied && !dailyPuzzleSolved && !isScrambling && dailyPuzzleReady) {
                const isSolved = isCubeSolved();
                if (isSolved) {
                    dailyPuzzleSolved = true;
                    showStatsPopup('Daily Puzzle');
                }
            }
            
            // Check for manual scramble solve
            if (manualScrambleActive && !manualScrambleSolved && !isScrambling) {
                const isSolved = isCubeSolved();
                if (isSolved) {
                    manualScrambleSolved = true;
                    showStatsPopup('Manual Scramble');
                }
            }
            
            // Check for new puzzle solve
            if (newPuzzleActive && !newPuzzleSolved && !isScrambling) {
                const isSolved = isCubeSolved();
                if (isSolved) {
                    newPuzzleSolved = true;
                    showStatsPopup('New Puzzle');
                }
            }
        }

        // Function to check if cube is solved by comparing colors
        function isCubeSolved() {
            // Define the solved state colors for each face
            const solvedColors = {
                front: colors.blue,   // Blue
                back: colors.green,   // Green
                top: colors.white,    // White
                bottom: colors.yellow, // Yellow
                left: colors.orange,  // Orange
                right: colors.red     // Red
            };
            
            // Check each face
            const faces = ['front', 'back', 'top', 'bottom', 'left', 'right'];
            
            for (const face of faces) {
                if (!isFaceSolved(face, solvedColors[face])) {
                    return false;
                }
            }
            
            return true;
        }

        // Function to check if a specific face is solved
        function isFaceSolved(face, expectedColor) {
            const faceIndices = getFaceIndices(face);
            
            for (const index of faceIndices) {
                const cubelet = cubelets[index];
                const material = getFaceMaterial(cubelet, face);
                
                if (material.color.getHex() !== expectedColor) {
                    return false;
                }
            }
            
            return true;
        }

        // Function to get cubelet indices for a specific face
        function getFaceIndices(face) {
            const indices = [];
            
            for (let i = 0; i < cubelets.length; i++) {
                const cubelet = cubelets[i];
                const pos = cubelet.position;
                
                switch (face) {
                    case 'front':
                        if (Math.abs(pos.z - 1) < 0.1) indices.push(i);
                        break;
                    case 'back':
                        if (Math.abs(pos.z + 1) < 0.1) indices.push(i);
                        break;
                    case 'top':
                        if (Math.abs(pos.y - 1) < 0.1) indices.push(i);
                        break;
                    case 'bottom':
                        if (Math.abs(pos.y + 1) < 0.1) indices.push(i);
                        break;
                    case 'left':
                        if (Math.abs(pos.x + 1) < 0.1) indices.push(i);
                        break;
                    case 'right':
                        if (Math.abs(pos.x - 1) < 0.1) indices.push(i);
                        break;
                }
            }
            
            return indices;
        }

        // Function to get the material for a specific face of a cubelet
        function getFaceMaterial(cubelet, face) {
            const pos = cubelet.position;
            const materials = cubelet.material;
            
            // Determine which material corresponds to the face
            if (Math.abs(pos.x - 1) < 0.1 && face === 'right') return materials[0];
            if (Math.abs(pos.x + 1) < 0.1 && face === 'left') return materials[1];
            if (Math.abs(pos.y - 1) < 0.1 && face === 'top') return materials[2];
            if (Math.abs(pos.y + 1) < 0.1 && face === 'bottom') return materials[3];
            if (Math.abs(pos.z - 1) < 0.1 && face === 'front') return materials[4];
            if (Math.abs(pos.z + 1) < 0.1 && face === 'back') return materials[5];
            
            // For edge and corner pieces, find the material that faces the correct direction
            if (face === 'right' && pos.x > 0) return materials[0];
            if (face === 'left' && pos.x < 0) return materials[1];
            if (face === 'top' && pos.y > 0) return materials[2];
            if (face === 'bottom' && pos.y < 0) return materials[3];
            if (face === 'front' && pos.z > 0) return materials[4];
            if (face === 'back' && pos.z < 0) return materials[5];
            
            return null;
        }

        // Function to show statistics popup
        function showStatsPopup(type) {
            let startTime, attempts, difficulty = '';
            
            if (type === 'Daily Puzzle') {
                startTime = dailyPuzzleStartTime;
                attempts = dailyPuzzleAttempts;
                // Reset attempts counter after successful solve
                dailyPuzzleAttempts = 0;
            } else if (type === 'Manual Scramble') {
                startTime = manualScrambleStartTime;
                attempts = manualScrambleAttempts;
                // Reset attempts counter after successful solve
                manualScrambleAttempts = 0;
            } else if (type === 'New Puzzle') {
                startTime = newPuzzleStartTime;
                attempts = newPuzzleAttempts;
                difficulty = newPuzzleDifficulty;
                // Reset attempts counter after successful solve
                newPuzzleAttempts = 0;
            } else {
                return;
            }
            
            const timeElapsed = Date.now() - startTime;
            const minutes = Math.floor(timeElapsed / 60000);
            const seconds = Math.floor((timeElapsed % 60000) / 1000);
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Get elements with error checking
            const movesUsedElement = document.getElementById('moves-used');
            const timeTakenElement = document.getElementById('time-taken');
            const attemptsElement = document.getElementById('attempts');
            const statsOverlayElement = document.getElementById('stats-overlay');
            const statsPopupElement = document.getElementById('stats-popup');
            const titleElement = document.querySelector('#stats-popup h2');
            
            // Check if all required elements exist
            if (!movesUsedElement || !timeTakenElement || !attemptsElement || 
                !statsOverlayElement || !statsPopupElement || !titleElement) {
                console.error('Stats popup elements not found:', {
                    movesUsed: !!movesUsedElement,
                    timeTaken: !!timeTakenElement,
                    attempts: !!attemptsElement,
                    statsOverlay: !!statsOverlayElement,
                    statsPopup: !!statsPopupElement,
                    title: !!titleElement
                });
                return;
            }
            
            // Update stats
            movesUsedElement.textContent = moveHistory.length;
            timeTakenElement.textContent = timeString;
            attemptsElement.textContent = attempts;
            
            // Update the title based on the type
            if (type === 'Daily Puzzle') {
                titleElement.textContent = 'ðŸŽ‰ Daily Puzzle Solved!';
            } else if (type === 'Manual Scramble') {
                titleElement.textContent = 'ðŸŽ‰ Manual Scramble Solved!';
            } else if (type === 'New Puzzle') {
                const difficultyText = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                titleElement.textContent = `ðŸŽ‰ ${difficultyText} Puzzle Solved!`;
            }
            
            // Show the popup
            statsOverlayElement.style.display = 'block';
            statsPopupElement.style.display = 'block';
        }

        // Function to close statistics popup
        function closeStatsPopup() {
            document.getElementById('stats-overlay').style.display = 'none';
            document.getElementById('stats-popup').style.display = 'none';
        }

        // Function to get daily puzzle moves without executing them
        function getDailyPuzzleMovesOnly() {
            return getDailyPuzzleMoves();
        }

        // Deterministic daily puzzle generator
        function getDailyPuzzleMoves() {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth() + 1; // getMonth() returns 0-11
            const day = today.getDate();
            
            // Generate seed: YYYY * 10000 + MM * 100 + DD
            const seed = year * 10000 + month * 100 + day;
            // console.log(`Date: ${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}, Seed: ${seed}`);
            
            // Simple linear congruential generator
            let randomState = seed;
            function nextRandom() {
                randomState = (randomState * 1103515245 + 12345) & 0x7fffffff;
                return randomState / 0x7fffffff;
            }
            
            const movePool = ['U', "U'", 'D', "D'", 'L', "L'", 'R', "R'", 'F', "F'", 'B', "B'"];
            const moves = [];
            let previousMove = null;
            
            // Generate exactly 3 moves
            for (let i = 0; i < 3; i++) {
                let move;
                do {
                    const randomIndex = Math.floor(nextRandom() * movePool.length);
                    move = movePool[randomIndex];
                } while (isUndoMove(previousMove, move)); // Avoid undo moves
                
                moves.push(move);
                previousMove = move;
            }
            
            return moves;
        }

        // Check if a move undoes the previous move
        function isUndoMove(previousMove, currentMove) {
            if (!previousMove) return false;
            
            const undoPairs = {
                'U': "U'",
                "U'": 'U',
                'D': "D'",
                "D'": 'D',
                'L': "L'",
                "L'": 'L',
                'R': "R'",
                "R'": 'R',
                'F': "F'",
                "F'": 'F',
                'B': "B'",
                "B'": 'B'
            };
            
            return undoPairs[previousMove] === currentMove;
        }

        // Cube state data structure
        class CubeState {
            constructor() {
                // Initialize with solved state
                this.state = {
                    front: Array(3).fill().map(() => Array(3).fill(colors.blue)),
                    back: Array(3).fill().map(() => Array(3).fill(colors.green)),
                    top: Array(3).fill().map(() => Array(3).fill(colors.white)),
                    bottom: Array(3).fill().map(() => Array(3).fill(colors.yellow)),
                    left: Array(3).fill().map(() => Array(3).fill(colors.orange)),
                    right: Array(3).fill().map(() => Array(3).fill(colors.red))
                };
            }

            // Convert visual cube state to data structure
            static fromVisual(cubelets) {
                const state = new CubeState();
                
                cubelets.forEach(cubelet => {
                    const pos = cubelet.position;
                    const materials = cubelet.material;

                    // Convert position to array indices (0-2)
                    // For x: -1 -> 0, 0 -> 1, 1 -> 2
                    // For y: -1 -> 2, 0 -> 1, 1 -> 0 (invert y for top-to-bottom)
                    // For z: -1 -> 0, 0 -> 1, 1 -> 2
                    const x = Math.round(pos.x + 1);
                    const y = 2 - Math.round(pos.y + 1); // Invert y coordinate
                    const z = Math.round(pos.z + 1);

                    // Update each face in the state based on position and materials
                    if (Math.abs(pos.x) === 1) {
                        if (pos.x > 0) {
                            // Right face - map from right to left, top to bottom
                            state.state.right[y][2 - z] = materials[0].color.getHex();
                        } else {
                            // Left face - map from left to right, top to bottom
                            state.state.left[y][z] = materials[1].color.getHex();
                        }
                    }
                    if (Math.abs(pos.y) === 1) {
                        if (pos.y > 0) {
                            // Top face - map from left to right, front to back
                            state.state.top[x][z] = materials[2].color.getHex();
                        } else {
                            // Bottom face - map from left to right, front to back
                            state.state.bottom[x][z] = materials[3].color.getHex();
                        }
                    }
                    if (Math.abs(pos.z) === 1) {
                        if (pos.z > 0) {
                            // Front face - map from left to right, top to bottom
                            state.state.front[x][y] = materials[4].color.getHex();
                        } else {
                            // Back face - map from right to left, top to bottom
                            state.state.back[x][2 - y] = materials[5].color.getHex();
                        }
                    }
                });

                // console.log('State after fromVisual:', state.state);
                return state;
            }

            // Convert data structure to visual cube state
            toVisual(cubelets) {
                cubelets.forEach(cubelet => {
                    const pos = {
                        x: Math.round(cubelet.position.x + 1),
                        y: Math.round(cubelet.position.y + 1),
                        z: Math.round(cubelet.position.z + 1)
                    };

                    const materials = cubelet.material;
                    
                    // Reset all materials to black first
                    materials.forEach(material => {
                        material.color.setHex(0x000000);
                    });

                    // Set colors based on position and state
                    if (pos.x === 2) materials[0].color.setHex(this.state.right[pos.y][pos.z]);
                    if (pos.x === 0) materials[1].color.setHex(this.state.left[pos.y][pos.z]);
                    if (pos.y === 2) materials[2].color.setHex(this.state.top[pos.x][pos.z]);
                    if (pos.y === 0) materials[3].color.setHex(this.state.bottom[pos.x][pos.z]);
                    if (pos.z === 2) materials[4].color.setHex(this.state.front[pos.x][pos.y]);
                    if (pos.z === 0) materials[5].color.setHex(this.state.back[pos.x][pos.y]);
                });
            }

            // Rotate a face in the data structure
            rotateFace(face, clockwise = true) {
                const faceData = this.state[face];
                const temp = Array(3).fill().map(() => Array(3).fill(0));

                // Rotate the face itself
                if (clockwise) {
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            temp[j][2 - i] = faceData[i][j];
                        }
                    }
                } else {
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            temp[2 - j][i] = faceData[i][j];
                        }
                    }
                }

                this.state[face] = temp;

                // Update adjacent faces
                this.updateAdjacentFaces(face, clockwise);
            }

            // Update adjacent faces after rotation
            updateAdjacentFaces(face, clockwise = true) {
                const temp = Array(3).fill(0);
                
                switch (face) {
                    case 'front':
                        // Store top row
                        for (let i = 0; i < 3; i++) {
                            temp[i] = this.state.top[2][i];
                        }
                        if (clockwise) {
                            // Move left to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[2][i] = this.state.left[2 - i][2];
                            }
                            // Move bottom to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[i][2] = this.state.bottom[0][i];
                            }
                            // Move right to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[0][i] = this.state.right[2 - i][0];
                            }
                            // Move stored top to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[i][0] = temp[i];
                            }
                        } else {
                            // Move right to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[2][i] = this.state.right[i][0];
                            }
                            // Move bottom to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[2 - i][0] = this.state.bottom[0][i];
                            }
                            // Move left to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[0][i] = this.state.left[i][2];
                            }
                            // Move stored top to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[2 - i][2] = temp[i];
                            }
                        }
                        break;

                    case 'back':
                        // Store top row
                        for (let i = 0; i < 3; i++) {
                            temp[i] = this.state.top[0][i];
                        }
                        if (clockwise) {
                            // Move right to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[0][i] = this.state.right[2 - i][2];
                            }
                            // Move bottom to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[i][2] = this.state.bottom[2][i];
                            }
                            // Move left to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[2][i] = this.state.left[2 - i][0];
                            }
                            // Move stored top to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[i][0] = temp[i];
                            }
                        } else {
                            // Move left to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[0][i] = this.state.left[i][0];
                            }
                            // Move bottom to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[2 - i][0] = this.state.bottom[2][i];
                            }
                            // Move right to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[2][i] = this.state.right[i][2];
                            }
                            // Move stored top to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[2 - i][2] = temp[i];
                            }
                        }
                        break;

                    case 'top':
                        // Store front row
                        for (let i = 0; i < 3; i++) {
                            temp[i] = this.state.front[0][i];
                        }
                        if (clockwise) {
                            // Move right to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[0][i] = this.state.right[0][i];
                            }
                            // Move back to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[0][i] = this.state.back[0][i];
                            }
                            // Move left to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[0][i] = this.state.left[0][i];
                            }
                            // Move stored front to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[0][i] = temp[i];
                            }
                        } else {
                            // Move left to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[0][i] = this.state.left[0][i];
                            }
                            // Move back to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[0][i] = this.state.back[0][i];
                            }
                            // Move right to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[0][i] = this.state.right[0][i];
                            }
                            // Move stored front to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[0][i] = temp[i];
                            }
                        }
                        break;

                    case 'bottom':
                        // Store front row
                        for (let i = 0; i < 3; i++) {
                            temp[i] = this.state.front[2][i];
                        }
                        if (clockwise) {
                            // Move left to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[2][i] = this.state.left[2][i];
                            }
                            // Move back to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[2][i] = this.state.back[2][i];
                            }
                            // Move right to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[2][i] = this.state.right[2][i];
                            }
                            // Move stored front to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[2][i] = temp[i];
                            }
                        } else {
                            // Move right to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[2][i] = this.state.right[2][i];
                            }
                            // Move back to right
                            for (let i = 0; i < 3; i++) {
                                this.state.right[2][i] = this.state.back[2][i];
                            }
                            // Move left to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[2][i] = this.state.left[2][i];
                            }
                            // Move stored front to left
                            for (let i = 0; i < 3; i++) {
                                this.state.left[2][i] = temp[i];
                            }
                        }
                        break;

                    case 'right':
                        // Store front column
                        for (let i = 0; i < 3; i++) {
                            temp[i] = this.state.front[i][2];
                        }
                        if (clockwise) {
                            // Move top to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[i][2] = this.state.top[2 - i][2];
                            }
                            // Move back to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[i][2] = this.state.back[2 - i][0];
                            }
                            // Move bottom to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[i][0] = this.state.bottom[i][2];
                            }
                            // Move stored front to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[i][2] = temp[i];
                            }
                        } else {
                            // Move bottom to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[i][2] = this.state.bottom[i][2];
                            }
                            // Move back to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[i][2] = this.state.back[2 - i][0];
                            }
                            // Move top to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[i][0] = this.state.top[2 - i][2];
                            }
                            // Move stored front to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[i][2] = temp[i];
                            }
                        }
                        break;

                    case 'left':
                        // Store front column
                        for (let i = 0; i < 3; i++) {
                            temp[i] = this.state.front[i][0];
                        }
                        if (clockwise) {
                            // Move bottom to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[i][0] = this.state.bottom[i][0];
                            }
                            // Move back to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[i][0] = this.state.back[2 - i][2];
                            }
                            // Move top to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[i][2] = this.state.top[2 - i][0];
                            }
                            // Move stored front to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[i][0] = temp[i];
                            }
                        } else {
                            // Move top to front
                            for (let i = 0; i < 3; i++) {
                                this.state.front[i][0] = this.state.top[i][0];
                            }
                            // Move back to top
                            for (let i = 0; i < 3; i++) {
                                this.state.top[2 - i][0] = this.state.back[i][2];
                            }
                            // Move bottom to back
                            for (let i = 0; i < 3; i++) {
                                this.state.back[2 - i][2] = this.state.bottom[i][0];
                            }
                            // Move stored front to bottom
                            for (let i = 0; i < 3; i++) {
                                this.state.bottom[i][0] = temp[i];
                            }
                        }
                        break;
                }
            }

            // Get string representation of the cube state
            toString() {
                return JSON.stringify(this.state, null, 2);
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Improved lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 5, 5);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);
            
            createCube();
            updateCubeStateDisplay();
            
            animate();
        }

        function createCubeletMaterials(x, y, z) {
            const materials = [];
            for (let i = 0; i < 6; i++) {
                let color = 0x000000; // Default to black for all faces
                
                // Only set colors for faces that are on the outside of the cube
                switch (i) {
                    case 0: // right
                        if (x === 1) color = colors.red;
                        break;
                    case 1: // left
                        if (x === -1) color = colors.orange;
                        break;
                    case 2: // top
                        if (y === 1) color = colors.white;
                        break;
                    case 3: // bottom
                        if (y === -1) color = colors.yellow;
                        break;
                    case 4: // front
                        if (z === 1) color = colors.blue;
                        break;
                    case 5: // back
                        if (z === -1) color = colors.green;
                        break;
                }
                
                materials.push(new THREE.MeshPhongMaterial({ 
                    color,
                    shininess: 0
                }));
            }
            return materials;
        }

        function createCube() {
            const geometry = new THREE.BoxGeometry(CUBELET_SIZE, CUBELET_SIZE, CUBELET_SIZE);

            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = createCubeletMaterials(x, y, z);
                        const cubelet = new THREE.Mesh(geometry, materials);
                        cubelet.position.set(x, y, z);
                        cubelet.userData.originalPosition = { x, y, z };
                        scene.add(cubelet);
                        cubelets.push(cubelet);
                    }
                }
            }
        }

        function startRotation(face, angle, isUndo = false) {
            if (isAnimating) return;
            
            isAnimating = true;
            currentRotation = 0;
            targetRotation = angle;
            rotatingFace = face;
            rotatingCubes = [];

            // Get all cubelets that should rotate (including edge pieces)
            switch (face) {
                case 'white':
                    rotatingAxis.set(0, 1, 0);
                    rotatingCubes = cubelets.filter(c => {
                        const pos = c.position;
                        return Math.abs(pos.y - 1) < 0.1;
                    });
                    rotatingPivot.set(0, 1, 0);
                    break;
                case 'yellow':
                    rotatingAxis.set(0, -1, 0);
                    rotatingCubes = cubelets.filter(c => {
                        const pos = c.position;
                        return Math.abs(pos.y + 1) < 0.1;
                    });
                    rotatingPivot.set(0, -1, 0);
                    break;
                case 'red':
                    rotatingAxis.set(1, 0, 0);
                    rotatingCubes = cubelets.filter(c => {
                        const pos = c.position;
                        return Math.abs(pos.x - 1) < 0.1;
                    });
                    rotatingPivot.set(1, 0, 0);
                    break;
                case 'orange':
                    rotatingAxis.set(-1, 0, 0);
                    rotatingCubes = cubelets.filter(c => {
                        const pos = c.position;
                        return Math.abs(pos.x + 1) < 0.1;
                    });
                    rotatingPivot.set(-1, 0, 0);
                    break;
                case 'blue':
                    rotatingAxis.set(0, 0, 1);
                    rotatingCubes = cubelets.filter(c => {
                        const pos = c.position;
                        return Math.abs(pos.z - 1) < 0.1;
                    });
                    rotatingPivot.set(0, 0, 1);
                    break;
                case 'green':
                    rotatingAxis.set(0, 0, -1);
                    rotatingCubes = cubelets.filter(c => {
                        const pos = c.position;
                        return Math.abs(pos.z + 1) < 0.1;
                    });
                    rotatingPivot.set(0, 0, -1);
                    break;
            }

            // Store the move in history if it's not an undo operation
            if (!isUndo && !isScrambling) {
                moveHistory.push({ face, angle });
            }
        }

        function updateRotation() {
            if (!isAnimating) return;

            const step = Math.min(ROTATION_SPEED, targetRotation - currentRotation);
            currentRotation += step;

            rotatingCubes.forEach(cubelet => {
                // Create a temporary vector for the position
                const pos = cubelet.position.clone();
                
                // Move to origin relative to pivot
                pos.sub(rotatingPivot);
                
                // Apply rotation
                pos.applyAxisAngle(rotatingAxis, rotateLeft*step);
                
                // Move back from origin
                pos.add(rotatingPivot);
                
                // Update position
                cubelet.position.copy(pos);
            });

            if (currentRotation >= targetRotation) {
                isAnimating = false;
                updateMaterials();
                updateCubeStateDisplay(); // Update display after rotation completes
                
                // Check if cube is solved after each move
                checkIfSolved();
                
                // If we're scrambling, start the next move
                if (isScrambling && scrambleQueue.length > 0) {
                    const move = scrambleQueue.shift();
                    rotateLeft = move.direction || 1; // Use move direction or default to 1
                    startRotation(move.face, move.angle);
                } else if (isScrambling) {
                    isScrambling = false;
                    // Show the cube when daily puzzle is complete
                    if (dailyPuzzleApplied) {
                        showCube();
                        dailyPuzzleReady = true; // Mark daily puzzle as ready for solving
                    }
                    // Show the cube when new puzzle is complete
                    if (newPuzzleActive) {
                        showCube();
                    }
                }
            }
        }

        function updateMaterials() {
            // Store original positions and materials
            const tempData = rotatingCubes.map(cubelet => ({
                position: cubelet.position.clone(),
                materials: cubelet.material.map(m => m.clone())
            }));

            // Update positions and materials
            rotatingCubes.forEach((cubelet, index) => {
                const materials = cubelet.material;
                const tempMaterials = tempData[index].materials;
                const pos = cubelet.position;

                // Update materials based on the face being rotated
                switch (rotatingFace) {
                    case 'white':
                        if(rotateLeft == 1){
                            materials[0] = tempMaterials[4]; // right
                            materials[1] = tempMaterials[5]; // left
                            materials[4] = tempMaterials[1]; // front
                            materials[5] = tempMaterials[0]; // back
                        } else {
                            materials[0] = tempMaterials[5]; // right
                            materials[1] = tempMaterials[4]; // left
                            materials[4] = tempMaterials[0]; // front
                            materials[5] = tempMaterials[1]; // back
                        }
                        break;
                    case 'yellow':
                        if(rotateLeft == 1){
                            materials[0] = tempMaterials[5]; // right
                            materials[1] = tempMaterials[4]; // left
                            materials[4] = tempMaterials[0]; // front
                            materials[5] = tempMaterials[1]; // back
                        } else {
                            materials[0] = tempMaterials[4]; // right
                            materials[1] = tempMaterials[5]; // left
                            materials[4] = tempMaterials[1]; // front
                            materials[5] = tempMaterials[0]; // back
                        }
                        break;
                    case 'red':
                        if(rotateLeft == 1){
                            materials[2] = tempMaterials[5]; // top
                            materials[3] = tempMaterials[4]; // bottom
                            materials[4] = tempMaterials[2]; // front
                            materials[5] = tempMaterials[3]; // back
                        } else {
                            materials[2] = tempMaterials[4]; // top
                            materials[3] = tempMaterials[5]; // bottom
                            materials[4] = tempMaterials[3]; // front
                            materials[5] = tempMaterials[2]; // back
                        }
                        break;
                    case 'orange':
                        if (rotateLeft == 1){
                            materials[2] = tempMaterials[4]; // top
                            materials[3] = tempMaterials[5]; // bottom
                            materials[4] = tempMaterials[3]; // front
                            materials[5] = tempMaterials[2]; // back
                        } else {
                            materials[2] = tempMaterials[5]; // top
                            materials[3] = tempMaterials[4]; // bottom
                            materials[4] = tempMaterials[2]; // front
                            materials[5] = tempMaterials[3]; // back
                        }
                        break;
                    case 'blue':
                        if (rotateLeft == 1){
                            materials[0] = tempMaterials[3]; // right
                            materials[1] = tempMaterials[2]; // left
                            materials[2] = tempMaterials[0]; // top
                            materials[3] = tempMaterials[1]; // bottom
                        } else {
                            materials[0] = tempMaterials[2]; // right
                            materials[1] = tempMaterials[3]; // left
                            materials[2] = tempMaterials[1]; // top
                            materials[3] = tempMaterials[0]; // bottom
                        }
                        break;
                    case 'green':
                        if (rotateLeft == 1) {
                            materials[0] = tempMaterials[2]; // right
                            materials[1] = tempMaterials[3]; // left
                            materials[2] = tempMaterials[1]; // top
                            materials[3] = tempMaterials[0]; // bottom
                        } else {
                            materials[0] = tempMaterials[3]; // right
                            materials[1] = tempMaterials[2]; // left
                            materials[2] = tempMaterials[0]; // top
                            materials[3] = tempMaterials[1]; // bottom
                        }
                        break;
                }
                // Update colors based on final position
//                if (Math.abs(pos.x) === 1) {
//                    materials[0].color.setHex(pos.x > 0 ? colors.red : colors.orange);
//                    materials[1].color.setHex(pos.x < 0 ? colors.orange : colors.red);
//                }
//                if (Math.abs(pos.y) === 1) {
//                    materials[2].color.setHex(pos.y > 0 ? colors.white : colors.yellow);
//                    materials[3].color.setHex(pos.y < 0 ? colors.yellow : colors.white);
//                }
//                if (Math.abs(pos.z) === 1) {
//                    materials[4].color.setHex(pos.z > 0 ? colors.blue : colors.green);
//                    materials[5].color.setHex(pos.z < 0 ? colors.green : colors.blue);
//                }
            });

            // Update the cube state display
            updateCubeStateDisplay();
        }

        function updateCubeStateDisplay() {
            // console.log('Updating cube state display...');
            
            // Create a new cube state from the current visual state
            const cubeState = CubeState.fromVisual(cubelets);
            // console.log('Current cube state:', cubeState.state);
            
            // Helper function to format a face
            const formatFace = (face, colors) => {
                // console.log(`Formatting ${face} face:`, colors);
                return `${face.toUpperCase()}:\n${colors.map(row => 
                    row.map(color => {
                        // Convert color to hex string for comparison
                        const colorHex = color.toString(16);
                        switch(colorHex) {
                            case 'ffffff': return 'W';
                            case 'ffff00': return 'Y';
                            case 'ff0000': return 'R';
                            case 'ffa500': return 'O';
                            case 'ff': return 'B';
                            case 'ff00': return 'G';
                            default: 
                                // console.warn(`Unknown color value: ${colorHex} for face ${face}`);
                                return '?';
                        }
                    }).join(' ')
                ).join('\n')}`;
            };

            try {
                // Update each face display
                const faces = ['top', 'right', 'front', 'back', 'bottom', 'left'];
                faces.forEach(face => {
                    const element = document.getElementById(`${face}-face`);
                    if (!element) {
                        // console.error(`Element not found for face: ${face}`);
                        return;
                    }
                    const faceColors = cubeState.state[face];
                    if (!faceColors) {
                        // console.error(`No colors found for face: ${face}`);
                        return;
                    }
                    element.textContent = formatFace(face, faceColors);
                });
                // console.log('Cube state display updated successfully');
            } catch (error) {
                // console.error('Error updating cube state display:', error);
            }
        }

        function resetCube() {
            if (isAnimating) return;
            
            // Clear scramble queue and reset scrambling state
            scrambleQueue = [];
            isScrambling = false;
            dailyPuzzleApplied = false;
            
            // Reset daily puzzle statistics
            dailyPuzzleStartTime = null;
            dailyPuzzleSolved = false;
            solvedState = null;
            dailyPuzzleReady = false;
            
            // Reset manual scramble statistics
            manualScrambleStartTime = null;
            manualScrambleAttempts = 0;
            manualScrambleSolved = false;
            manualScrambleActive = false;
            
            // Reset new puzzle statistics
            newPuzzleStartTime = null;
            newPuzzleAttempts = 0;
            newPuzzleSolved = false;
            newPuzzleActive = false;
            newPuzzleDifficulty = '';
            
            // Ensure cube is visible
            showCube();
            
            // Reset all cubelets to their original positions and materials
            cubelets.forEach(cubelet => {
                // Reset position
                cubelet.position.set(
                    cubelet.userData.originalPosition.x,
                    cubelet.userData.originalPosition.y,
                    cubelet.userData.originalPosition.z
                );
                
                // Reset materials to original colors
                const materials = cubelet.material;
                const x = cubelet.userData.originalPosition.x;
                const y = cubelet.userData.originalPosition.y;
                const z = cubelet.userData.originalPosition.z;
                
                // Reset all materials to black first
                materials.forEach(material => {
                    material.color.setHex(0x000000);
                });
                
                // Set colors for outside faces
                if (x === 1) materials[0].color.setHex(colors.red);
                if (x === -1) materials[1].color.setHex(colors.orange);
                if (y === 1) materials[2].color.setHex(colors.white);
                if (y === -1) materials[3].color.setHex(colors.yellow);
                if (z === 1) materials[4].color.setHex(colors.blue);
                if (z === -1) materials[5].color.setHex(colors.green);
            });
            
            // Clear move history
            moveHistory = [];
            
            // Update the cube state display
            updateCubeStateDisplay();
        }

        function scrambleCube() {
            if (isScrambling) return;
            
            isScrambling = true;
            dailyPuzzleApplied = false; // Reset daily puzzle flag
            
            // Reset daily puzzle statistics
            dailyPuzzleStartTime = null;
            dailyPuzzleSolved = false;
            solvedState = null;
            dailyPuzzleReady = false;
            
            // Reset new puzzle statistics
            newPuzzleStartTime = null;
            newPuzzleAttempts = 0;
            newPuzzleSolved = false;
            newPuzzleActive = false;
            newPuzzleDifficulty = '';
            
            // Initialize manual scramble statistics tracking
            manualScrambleStartTime = Date.now();
            manualScrambleAttempts++;
            manualScrambleSolved = false;
            manualScrambleActive = true;
            
            // Store the solved state for comparison
            solvedState = new CubeState();
            
            // Ensure cube is visible for manual scramble
            showCube();
            
            const faces = ['white', 'yellow', 'red', 'orange', 'blue', 'green'];
            const moves = 20;
            
            // Clear move history before scrambling
            moveHistory = [];
            
            // Create queue of moves
            for (let i = 0; i < moves; i++) {
                const face = faces[Math.floor(Math.random() * faces.length)];
                const angle = Math.PI / 2;
                scrambleQueue.push({ face, angle });
            }
            
            // Start the first move
            if (scrambleQueue.length > 0) {
                const move = scrambleQueue.shift();
                startRotation(move.face, move.angle);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateRotation();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('keydown', (event) => {
            if (isAnimating) return;
            
            rotateLeft = event.shiftKey ? -1 : 1;
            switch (event.key.toLowerCase()) {
                case 'w':
                    startRotation('white', Math.PI / 2);
                    break;
                case 'y':
                    startRotation('yellow', Math.PI / 2);
                    break;
                case 'r':
                    startRotation('red', Math.PI / 2);
                    break;
                case 'o':
                    startRotation('orange', Math.PI / 2);
                    break;
                case 'b':
                    startRotation('blue', Math.PI / 2);
                    break;
                case 'g':
                    startRotation('green', Math.PI / 2);
                    break;
            }
        });

        init();

        // Global function for testing - can be called from browser console
        window.getTodaysPuzzle = function() {
            const moves = getDailyPuzzleMoves();
            // console.log('Today\'s puzzle moves:', moves);
            return moves;
        };

        // New Puzzle Generator
        function showDifficultyDropdown() {
            // Remove existing dropdown if present
            const existingDropdown = document.querySelector('.difficulty-dropdown');
            const existingOverlay = document.getElementById('difficulty-overlay');
            if (existingDropdown) existingDropdown.remove();
            if (existingOverlay) existingOverlay.remove();
            
            const overlay = document.createElement('div');
            overlay.id = 'difficulty-overlay';
            overlay.className = 'popup-overlay';
            overlay.onclick = () => {
                overlay.remove();
                dropdown.remove();
            };
            
            const dropdown = document.createElement('div');
            dropdown.className = 'difficulty-dropdown';
            dropdown.innerHTML = `
                <h3>Select Difficulty</h3>
                <button class="difficulty-option" onclick="generateNewPuzzle('easy')">
                    Easy <span class="move-count">(3 moves)</span>
                </button>
                <button class="difficulty-option" onclick="generateNewPuzzle('medium')">
                    Medium <span class="move-count">(5 moves)</span>
                </button>
                <button class="difficulty-option" onclick="generateNewPuzzle('hard')">
                    Hard <span class="move-count">(7 moves)</span>
                </button>
                <button class="difficulty-option" onclick="generateNewPuzzle('expert')">
                    Expert <span class="move-count">(9 moves)</span>
                </button>
                <button class="difficulty-option" onclick="generateNewPuzzle('insane')">
                    Insane <span class="move-count">(11 moves)</span>
                </button>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(dropdown);
        }

        function generateNewPuzzle(difficulty) {
            // Remove dropdown and overlay - use specific IDs
            const dropdown = document.querySelector('.difficulty-dropdown');
            const overlay = document.getElementById('difficulty-overlay');
            if (dropdown) dropdown.remove();
            if (overlay) overlay.remove();
            
            // Always reset the cube to solved state before applying new puzzle
            resetCube();
            
            // Reset puzzle state
            resetPuzzleState();
            
            // Generate moves based on difficulty
            let moveCount;
            switch(difficulty) {
                case 'easy': moveCount = 3; break;
                case 'medium': moveCount = 5; break;
                case 'hard': moveCount = 7; break;
                case 'expert': moveCount = 9; break;
                case 'insane': moveCount = 11; break;
                default: moveCount = 3;
            }
            
            // Generate puzzle moves
            const puzzleMoves = generatePuzzleMoves(moveCount, difficulty);
            
            // Hide cube and execute puzzle moves
            hideCube();
            executePuzzleMoves(puzzleMoves, difficulty);
        }

        function generatePuzzleMoves(moveCount, difficulty) {
            const movePool = ['U', "U'", 'D', "D'", 'L', "L'", 'R', "R'", 'F', "F'", 'B', "B'"];
            const moves = [];
            let previousMove = null;
            
            // Generate moves based on difficulty
            for (let i = 0; i < moveCount; i++) {
                let move;
                do {
                    const randomIndex = Math.floor(Math.random() * movePool.length);
                    move = movePool[randomIndex];
                } while (isUndoMove(previousMove, move)); // Avoid undo moves
                
                moves.push(move);
                previousMove = move;
            }
            
            return moves;
        }

        function executePuzzleMoves(moves, difficulty) {
            if (isScrambling) return;
            
            // Initialize new puzzle statistics tracking
            newPuzzleStartTime = Date.now();
            newPuzzleAttempts++;
            newPuzzleSolved = false;
            newPuzzleActive = true;
            newPuzzleDifficulty = difficulty; // Store the difficulty
            
            // Store the solved state for comparison
            solvedState = new CubeState();
            
            // Clear move history and scramble queue
            moveHistory = [];
            scrambleQueue = [];
            
            // Convert moves to rotation commands
            const moveToRotation = {
                'U': { face: 'white', angle: Math.PI / 2, direction: 1 },
                "U'": { face: 'white', angle: Math.PI / 2, direction: -1 },
                'D': { face: 'yellow', angle: Math.PI / 2, direction: 1 },
                "D'": { face: 'yellow', angle: Math.PI / 2, direction: -1 },
                'L': { face: 'orange', angle: Math.PI / 2, direction: 1 },
                "L'": { face: 'orange', angle: Math.PI / 2, direction: -1 },
                'R': { face: 'red', angle: Math.PI / 2, direction: 1 },
                "R'": { face: 'red', angle: Math.PI / 2, direction: -1 },
                'F': { face: 'blue', angle: Math.PI / 2, direction: 1 },
                "F'": { face: 'blue', angle: Math.PI / 2, direction: -1 },
                'B': { face: 'green', angle: Math.PI / 2, direction: 1 },
                "B'": { face: 'green', angle: Math.PI / 2, direction: -1 }
            };
            
            // Add moves to scramble queue
            moves.forEach(move => {
                const rotation = moveToRotation[move];
                if (rotation) {
                    scrambleQueue.push(rotation);
                }
            });
            
            // Start the first move
            if (scrambleQueue.length > 0) {
                isScrambling = true;
                const move = scrambleQueue.shift();
                rotateLeft = move.direction || 1;
                startRotation(move.face, move.angle);
            }
        }

        function resetPuzzleState() {
            // If new puzzle is already applied, reset the cube first
            if (newPuzzleActive) {
                resetCube();
                newPuzzleActive = false;
            }
            
            // Reset statistics
            newPuzzleStartTime = 0;
            newPuzzleSolved = false;
            newPuzzleActive = false;
        }
    </script>
</body>
</html> 
